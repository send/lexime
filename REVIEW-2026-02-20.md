# コードレビュー調査結果 (2026-02-20)

engine (Rust) および Swift ホスト側のコードベース全体を調査した結果をまとめる。

---

## 全体評価

### Rust engine

- アーキテクチャは明確に分離されている（dict / converter / session / FFI）
- `thiserror` による一貫したエラーハンドリング
- テストカバレッジが厚い（コーパステスト、proptest、integration tests）
- unsafe コードは全て memory-mapped I/O で安全なパターン
- dead code や TODO/FIXME コメントがほぼない

### Swift ホスト

- AppContext シングルトンによるリソース初期化が整理されている
- IMKInputController のイベントハンドリングが明確
- CandidateManager の generation カウンタによる非同期結果の stale 検出が適切
- VoiceOver 対応（候補パネルのアクセシビリティ通知）が実装済み
- エラーハンドリングは NSLog ベースで一貫している

---

## 対応を検討すべき項目

### 1. `ClearMarkedText` variant が未使用

- **場所**: `engine/src/api/types.rs:71` (定義), `:139` (変換ロジック)
- **内容**: `LexEvent::ClearMarkedText` が enum に定義されているが、`convert_to_events()` では空の `MarkedText` を `SetMarkedText { text: "" }` として変換しており、`ClearMarkedText` は一度も生成されない
- **テスト** (`:214-225`) でも空文字列 → `SetMarkedText` の挙動が assert されている
- **選択肢**:
  - A) `convert_to_events` で `text.is_empty()` のとき `ClearMarkedText` を生成するよう修正
  - B) Swift 側が `SetMarkedText { text: "" }` で問題なく動作しているなら variant を削除
- **優先度**: 中

### 2. FFI の `set_conversion_mode` が `u8` を受け取っている

- **場所**: `engine/src/api/session.rs:103-112`
- **内容**: `set_conversion_mode(mode: u8)` が `match mode { 1 => Predictive, _ => Standard }` でハードコード変換している。`ConversionMode` 自体は `lex-session/src/types/composition.rs:9-47` に enum として定義済み
- **問題**: 未知の値が来ても `Standard` にフォールバックするため、呼び出し側のバグが silent に無視される
- **対応案**: UniFFI は enum エクスポートをサポートしているので `ConversionMode` を `#[derive(uniffi::Enum)]` で公開し、型安全にする
- **優先度**: 中

### 3. `engine_version()` がハードコード

- **場所**: `engine/src/api/mod.rs:29`
- **内容**: `"0.1.0".to_string()` がリテラルで返されている
- **対応案**: `env!("CARGO_PKG_VERSION").to_string()` で `Cargo.toml` の `version` と自動同期
- **優先度**: 低

### 4. AsyncWorker のスレッド管理

- **場所**: `engine/src/async_worker.rs:54`
- **内容**: セッション生成ごとに `thread::Builder::new().spawn()` で detached スレッドを起動し、join handle を保持しない
- **現状の影響**: IME の通常利用ではセッション数が 1〜2 なので実害なし
- **潜在リスク**: 大量セッション生成時にスレッドがリークする
- **対応案**: thread pool (rayon/tokio) の導入、またはセッション drop 時にスレッドを join する仕組み
- **優先度**: 低（現状の利用パターンでは問題なし）

### 5. 組み込み TOML の `expect()` パニック

- **場所**: `engine/crates/lex-core/src/settings.rs` (3 箇所)
- **内容**: `parse_settings_toml(toml_str).expect("settings TOML must be valid")` で、組み込みの `default_settings.toml` をランタイムにパースしている。TOML に構文エラーがあればコンパイルは通るが起動時にパニックする
- **対応案**: `build.rs` で TOML の構文チェックを行い、不正ならコンパイルエラーにする
- **優先度**: 低（組み込みファイルが壊れる可能性は低い）

### 6. ユーザ辞書の保存失敗が UI に通知されない

- **場所**: `Sources/UserDictionaryView.swift:67-73` (addWord), `:81-85` (removeSelected)
- **内容**: `saveUserDict` の失敗は `NSLog` でログするのみで、ユーザには成功したように見える。`refresh()` がメモリ上の状態を表示するため、単語が登録/削除されたように見えるが、再起動後にはデータが消える（登録）/ 戻る（削除）
- **対応案**: 保存失敗時にアラートを表示し、ユーザに再試行やディスク容量の確認を促す
- **優先度**: 中

### 7. SettingsWindowController のウィンドウ再生成でリーク

- **場所**: `Sources/SettingsWindowController.swift:10-45`
- **内容**: `showWindow()` は `window.isVisible` で分岐しており、ウィンドウが閉じられた後に再度開くと新しい `NSWindow` を生成して `self.window` に代入する。旧ウィンドウは `isReleasedWhenClosed = false` のため解放されず、旧ウィンドウ用の `NotificationCenter` observer も残り続ける
- **影響**: 設定画面を開く→閉じる→開くを繰り返すたびに NSWindow と observer がリークする。実際にはユーザが頻繁に繰り返す操作ではないため影響は小さい
- **対応案**:
  - A) `windowDidClose()` で `window = nil` にして次回は新規生成（observer も removeObserver で解除）
  - B) `isVisible` チェックを外し、既存ウィンドウがあれば常に再利用する
- **優先度**: 低

---

## 調査の結果問題なしと判断した項目

### Mutex/RwLock の `.unwrap()` (lock poisoning)

- **場所**: `engine/src/api/session.rs` (6 箇所), `engine/crates/lex-core/src/user_dict/mod.rs` (6 箇所)
- **判断**: IME はパニック → OS による自動再起動が正しい復帰パス。poison された lock から不整合な状態を復元するより、クリーンに再起動する方がユーザ体験が良い

### `exit(0)` / `exit(1)` の使用

- **場所**: `Sources/main.swift:11,16` (`exit(1)`), `Sources/SettingsView.swift:83` (`exit(0)`)
- **判断**: `exit(1)` は IMKServer 生成前の初期化失敗時で、保存すべき状態がない。`exit(0)` は設定画面からの意図的な再起動トリガーで SPEC.md にも記載済み。macOS が IME を自動再起動するため現状の設計が正しい
- **WAL の安全性**: `exit(0)` で Rust 側の Drop が走らず WAL がフラッシュされない懸念があるが、以下の理由で問題ない:
  - WAL の `append()` は `File::write_all()` を直接使用しており、ユーザ空間バッファリングがない（`BufWriter` 不使用）。`write_all()` 完了時点でデータはカーネルのページキャッシュに入っている
  - `exit(0)` 後もカーネルはページキャッシュを保持するため、直後に再起動した新プロセスからファイル読み取りが可能
  - 万が一 `append()` の途中（3 回の `write_all` の間）でプロセスが終了しても、WAL の `replay()` が CRC 検証 + フレーム長チェック (`wal.rs:62-74`) で不完全フレームを検出・スキップする

### `#[allow(unused_imports)]`

- **場所**: `engine/crates/lex-core/src/converter/mod.rs:30`
- **判断**: `viterbi_nbest`, `RichSegment`, `ScoredPath` は `#[cfg(feature = "neural")]` と `#[cfg(test)]` で使用されるインポート。feature gate による条件付きコンパイルのための正当な使用

### `#[allow(clippy::too_many_arguments)]`

- **場所**: `engine/crates/lex-cli/src/commands/neural_ops.rs:155`
- **判断**: CLI ツールの `speculative_decode_cmd` 関数。research 用の feature-gated コードであり、引数を構造体にまとめる必要性は低い

### SPEC.md の状態

- **判断**: 現在のコードベースと整合しており、更新の必要なし

### `keymap` / `keymap_parsed` フィールド

- **場所**: `engine/crates/lex-core/src/settings.rs:58`
- **内容**: `keymap` を serde でパースした後 `keymap_parsed` に変換して使用。`keymap` 自体は直接参照されない
- **判断**: 内部実装の詳細であり、serde のデシリアライズ → 内部表現変換は一般的なパターン。issue 化不要

### CandidatePanel の配列アクセス (candidates[selectedIndex])

- **場所**: `Sources/CandidatePanel.swift:137`
- **判断**: 呼び出し元の `CandidateManager.show()` で `min(selectedIndex, candidates.count - 1)` によるクランプとページ計算が行われており、`pageSelectedIndex` は常に `pageCandidates` の範囲内。安全

### Timer クロージャのローカル変数キャプチャ (idleTicks)

- **場所**: `Sources/LeximeInputController.swift:151`
- **判断**: Swift のクロージャは mutable なローカル変数をヒープに昇格させてキャプチャする。関数スコープを抜けても変数はクロージャが保持するヒープ上に生存するため、未定義動作にはならない。Swift の正しい挙動

### CandidateManager のスレッド安全性

- **場所**: `Sources/CandidateManager.swift`, `Sources/LeximeInputController.swift`
- **判断**: `CandidateManager` へのアクセスは全て IMKInputController のメインスレッドコールバック、またはメインランループの Timer から行われる。`DispatchQueue.main.async` による候補パネル表示も generation カウンタでガードされている。スレッド安全性の問題なし

### UserDictionaryView の unregisterWord 戻り値

- **場所**: `Sources/UserDictionaryView.swift:80`
- **内容**: `_ = engine.unregisterWord(...)` で戻り値を捨てている
- **判断**: 直後に `saveUserDict` と `refresh()` が呼ばれるため、登録解除が失敗しても UI は正しい状態に収束する。ログ追加は好みの範囲
