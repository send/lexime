[tasks.engine-lib]
description = "Build universal static library (x86_64 + aarch64)"
sources = ["engine/src/**/*.rs", "engine/Cargo.toml", "engine/Cargo.lock", "engine/include/engine.h"]
outputs = ["build/liblex_engine.a"]
run = """
#!/usr/bin/env bash
set -euo pipefail
cd engine
cargo build --release --features trace,neural --target x86_64-apple-darwin
cargo build --release --features trace,neural --target aarch64-apple-darwin
cd ..
mkdir -p build
lipo -create \
  engine/target/x86_64-apple-darwin/release/liblex_engine.a \
  engine/target/aarch64-apple-darwin/release/liblex_engine.a \
  -output build/liblex_engine.a
"""

[tasks.fetch-dict-sudachi]
description = "Download SudachiDict dictionary data"
sources = ["engine/src/bin/dictool.rs", "engine/src/dict/source/sudachi.rs"]
outputs = ["engine/data/sudachi-raw/.stamp"]
run = "cd engine && cargo run --bin dictool -- fetch --source sudachi data/sudachi-raw"

[tasks.fetch-dict-mozc]
description = "Download Mozc dictionary data"
sources = ["engine/src/bin/dictool.rs", "engine/src/dict/source/mozc.rs"]
outputs = ["engine/data/mozc-raw/.stamp"]
run = "cd engine && cargo run --bin dictool -- fetch --source mozc data/mozc-raw"

[tasks.dict-mozc]
description = "Compile binary dictionary from Mozc"
depends = ["fetch-dict-mozc"]
sources = ["engine/data/mozc-raw/.stamp", "engine/src/bin/dictool.rs", "engine/src/dict/source/mozc.rs"]
outputs = ["engine/data/lexime-mozc.dict"]
run = """
#!/usr/bin/env bash
set -euo pipefail
cd engine
cargo build --release --bin dictool
target/release/dictool compile --source mozc data/mozc-raw data/lexime-mozc.dict
"""

[tasks.conn]
description = "Compile Mozc connection cost matrix"
depends = ["fetch-dict-mozc"]
sources = ["engine/data/mozc-raw/connection_single_column.txt", "engine/data/mozc-raw/id.def"]
outputs = ["engine/data/lexime.conn"]
run = """
#!/usr/bin/env bash
set -euo pipefail
cd engine
cargo build --release --bin dictool
target/release/dictool compile-conn \
  --id-def data/mozc-raw/id.def \
  data/mozc-raw/connection_single_column.txt data/lexime.conn
"""

[tasks.fetch-dict-sudachi-full]
description = "Download SudachiDict full dictionary data (core + notcore)"
depends = ["fetch-dict-sudachi"]
sources = ["engine/src/bin/dictool.rs", "engine/src/dict/source/sudachi.rs"]
outputs = ["engine/data/sudachi-full-raw/.stamp"]
run = "cd engine && cargo run --bin dictool -- fetch --source sudachi --full data/sudachi-full-raw"

[tasks.dict-sudachi-full]
description = "Compile binary dictionary from SudachiDict full (remapped to Mozc POS IDs)"
depends = ["fetch-dict-sudachi-full", "fetch-dict-mozc"]
sources = ["engine/data/sudachi-full-raw/.stamp"]
outputs = ["engine/data/lexime-sudachi-full.dict"]
run = """
#!/usr/bin/env bash
set -euo pipefail
cd engine
cargo build --release --bin dictool
target/release/dictool compile --source sudachi --remap-ids data/mozc-raw/id.def \
  data/sudachi-full-raw data/lexime-sudachi-full.dict
"""

[tasks.dict]
description = "Build dictionary (Mozc only)"
depends = ["dict-mozc"]
outputs = ["engine/data/lexime.dict"]
run = """
#!/usr/bin/env bash
set -euo pipefail
cp engine/data/lexime-mozc.dict engine/data/lexime.dict
"""

[tasks.dict-clean]
description = "Remove compiled dictionaries (forces rebuild on next dict/build)"
run = """
#!/usr/bin/env bash
rm -f engine/data/lexime-mozc.dict engine/data/lexime-sudachi.dict \
      engine/data/lexime-sudachi-full.dict engine/data/lexime.dict \
      engine/data/lexime.conn
echo "Removed compiled dictionaries"
"""

[tasks.build]
description = "Build Lexime.app (universal binary)"
depends = ["engine-lib", "dict", "conn"]
sources = [
  "Sources/*.swift",
  "Sources/Bridging-Header.h",
  "build/liblex_engine.a",
  "engine/data/lexime.dict",
  "engine/data/lexime.conn",
  "Info.plist",
  "Resources/icon.tiff",
  "Resources/en.lproj/InfoPlist.strings",
  "Resources/ja.lproj/InfoPlist.strings",
]
outputs = ["build/Lexime.app/Contents/MacOS/Lexime"]
run = """
#!/usr/bin/env bash
set -euo pipefail
rm -f ~/Library/Logs/Lexime/lexime-trace.jsonl
APP=build/Lexime.app
MACOS=$APP/Contents/MacOS
RES=$APP/Contents/Resources
MACOS_MIN=13.0
SWIFTC_FLAGS="-O -import-objc-header Sources/Bridging-Header.h -Xcc -I."
LINK_FLAGS="-Lbuild -llex_engine"

mkdir -p "$MACOS" "$RES"
swiftc $SWIFTC_FLAGS $LINK_FLAGS -target x86_64-apple-macosx$MACOS_MIN \
  Sources/*.swift -o "$MACOS/Lexime-x86_64"
swiftc $SWIFTC_FLAGS $LINK_FLAGS -target arm64-apple-macosx$MACOS_MIN \
  Sources/*.swift -o "$MACOS/Lexime-arm64"
lipo -create "$MACOS/Lexime-x86_64" "$MACOS/Lexime-arm64" -output "$MACOS/Lexime"
rm "$MACOS/Lexime-x86_64" "$MACOS/Lexime-arm64"
cp Info.plist "$APP/Contents/Info.plist"
cp Resources/icon.tiff "$RES/icon.tiff"
cp -R Resources/en.lproj "$RES/en.lproj"
cp -R Resources/ja.lproj "$RES/ja.lproj"
cp engine/data/lexime.dict "$RES/"
cp engine/data/lexime.conn "$RES/"
if [ -f data/zenz-v3.1-Q5_K_M.gguf ]; then
  cp data/zenz-v3.1-Q5_K_M.gguf "$RES/"
fi
codesign -f -s - "$APP"
echo "Build complete: $APP"
"""

[tasks.install]
description = "Install Lexime.app to ~/Library/Input Methods"
depends = ["build"]
run = """
#!/usr/bin/env bash
set -euo pipefail
INSTALL_DIR="$HOME/Library/Input Methods"
mkdir -p "$INSTALL_DIR"
rm -rf "$INSTALL_DIR/Lexime.app"
cp -R build/Lexime.app "$INSTALL_DIR/Lexime.app"
echo "Installed to $INSTALL_DIR/Lexime.app"
"""

[tasks.reload]
description = "Restart Lexime (macOS auto-restarts input methods)"
run = """
#!/usr/bin/env bash
pkill -x Lexime || true
echo "Sent kill signal to Lexime (macOS will auto-restart it)"
"""

[tasks.log]
description = "Stream Lexime log output"
run = """log stream --predicate 'process == "Lexime"' --style compact"""

[tasks.icon]
description = "Generate icon assets"
run = "bash scripts/icon.sh"

[tasks.test-swift]
description = "Run Swift unit tests (FFI round-trip)"
depends = ["engine-lib"]
# NOTE: Test files are listed explicitly because swiftc compiles all sources
# into one binary. If you add a new test file under Tests/, add it here too.
run = """
#!/usr/bin/env bash
set -euo pipefail
mkdir -p build
swiftc -import-objc-header Sources/Bridging-Header.h -Xcc -I. \
  -Lbuild -llex_engine \
  Tests/TestRunner.swift Tests/TestRomajiFFI.swift Tests/TestDictFFI.swift Tests/TestSessionFFI.swift \
  -o build/test-runner && build/test-runner
"""


[tasks.explain]
description = "Explain conversion pipeline for a reading"
run = """
cd engine && cargo run --release --bin lextool -- explain \
  data/lexime.dict "$@" --conn data/lexime.conn
"""

[tasks.snapshot]
description = "Generate conversion snapshot"
depends = ["dict", "conn"]
run = """
cd engine && cargo run --release --bin lextool -- snapshot \
  data/lexime.dict data/lexime.conn \
  data/snapshot-readings.txt data/snapshot.jsonl -n 5
"""

[tasks.diff-snapshot]
description = "Compare current output against baseline snapshot"
depends = ["dict", "conn"]
run = """
cd engine && cargo run --release --bin lextool -- diff-snapshot \
  data/lexime.dict data/lexime.conn \
  data/snapshot-readings.txt data/snapshot.jsonl -n 5
"""

[tasks.trace-log]
description = "Stream trace JSONL output"
run = "tail -f ~/Library/Logs/Lexime/lexime-trace.jsonl | python3 -m json.tool --no-ensure-ascii"

[tasks.fetch-model]
description = "Download Zenzai GGUF model"
run = """
#!/usr/bin/env bash
set -euo pipefail
mkdir -p data
if [ -f data/zenz-v3.1-Q5_K_M.gguf ]; then
  echo "Model already exists at data/zenz-v3.1-Q5_K_M.gguf"
  exit 0
fi
echo "Downloading zenz-v3.1-small-gguf (Q5_K_M, ~74MB)..."
curl -L -o data/zenz-v3.1-Q5_K_M.gguf \
  "https://huggingface.co/Miwa-Keita/zenz-v3.1-small-gguf/resolve/main/ggml-model-Q5_K_M.gguf"
echo "Downloaded to data/zenz-v3.1-Q5_K_M.gguf"
"""

[tasks.neural-score]
description = "Run neural scoring benchmark"
depends = ["fetch-model", "dict", "conn"]
run = """
cd engine && cargo run --features neural --bin dictool -- neural-score \
  data/lexime.dict data/lexime.conn \
  --model ../data/zenz-v3.1-Q5_K_M.gguf \
  "$@"
"""

[tasks.lint]
description = "Run cargo fmt --check and clippy (all features)"
run = [
  "cd engine && cargo fmt --check",
  "cd engine && cargo clippy --all-features -- -D warnings",
]

[tasks.test]
description = "Run lint + engine tests (all features)"
depends = ["lint"]
run = "cd engine && cargo test --all-features"

[tasks.clean]
description = "Remove build artifacts"
run = """
#!/usr/bin/env bash
rm -rf build
cd engine && cargo clean
echo "Clean complete"
"""
